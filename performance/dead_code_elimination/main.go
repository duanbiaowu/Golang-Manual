// See the doc: https://geektutu.com/post/hpg-dead-code-elimination.html

package main

import (
	"fmt"
	"log"
)

// debug 模式
// 我们可以在源代码中，定义全局常量 debug，值设置为 false，在需要增加调试代码的地方，使用条件语句 if debug 包裹
// 如果是正常编译，常量 debug 始终等于 false，调试语句在编译过程中会被消除，不会影响最终的二进制大小，也不会对运行效率产生任何影响。
// 如果我们想编译出 debug 版本的二进制呢？可以将 debug 修改为 true 之后编译。
// 这对于开发者日常调试是非常有帮助的，日常开发过程中，在进行单元测试或者是简单的集成测试时，希望能够执行一些额外的操作，
//	例如打印日志，或者是修改变量的值。提交代码时，再将 debug 修改为 false，
//	开发过程中增加的额外的调试代码在编译时会被消除，不会对正式版本产生任何的影响。

// 源代码中有很多这样的例子
// $ grep -nr "const debug = false" "$(dirname $(which go))/../src"
const debug = false

// go build -o maxconst main.go
// ls -sh maxconst
// 1.4M maxconst
const x, y = 10, 20

// go build -o maxvar main.go
// ls -sh maxvar
// 1.7M maxvar
//var a, b = 10, 20
// 全局变量 a、b 不为常量，编译器并不知道运行过程中 a、b 会不会发生改变，因此不能够进行死码消除，这部分代码被编译到最终的二进制程序中。
// 因此 maxvar 比 maxconst 二进制体积大了 0.3M

// 如果在 if 语句中，调用了更多的库，死码消除之后，体积差距会更大。
// 因此，在声明全局变量时，如果能够确定为常量，尽量使用 const 而非 var，这样很多运算在编译器即可执行。
// 死码消除后，既减小了二进制的体积，又可以提高运行时的效率，如果这部分代码是 hot path，那么对性能的提升会更加明显。

func max(num1, num2 int) int {
	if num1 > num2 {
		return num1
	}
	return num2
}

func main() {
	if max(x, y) == x {
		fmt.Println(x)
	}
	if debug {
		log.Println("debug mode is enabled")
	}
	if dev {
		log.Println("dev mode is enabled")
	}
}

// go build -gcflags=-m  -o maxconst main.go
//./main.go:17:6: can inline max
//./main.go:25:8: inlining call to max
//./main.go:26:14: inlining call to fmt.Println
//./main.go:26:14: x escapes to heap
//./main.go:26:14: []interface {}{...} does not escape
//<autogenerated>:1: leaking param content: .this

// max 函数被内联了，即被展开了，手动展开后如下
const expand = `
func main() {
	var result int
	if a > b {
		result = a
	} else {
		result = b
    }
	if result == a {
		fmt.Println(a)
	}
}
`

// 如果 a 和 b 均为常量（const）呢？那在编译阶段就可以直接进行计算：
const expand2 = `
func main() {
	var result int
	if 10 > 20 {
		result = 10
	} else {
		result = 20
    }
	if result == 10 {
		fmt.Println(a)
	}
}
`

// 计算之后，10 > 20 永远为假，那么分支消除后：
const expand3 = `
func main() {
	if 20 == 10 {
		fmt.Println(a)
	}
}
`
